---
title: "5주차 문제 풀이"
published: true
---

매주 문제만 풀고 풀이를 정리 안하면 까먹을 까봐 다른 사람을 보여주기 위한것보다는 내가 remind할 때 편하라고 간략하게라도 풀이를 적어야겠다 생각했다.

## 5주차 문제 풀이 

매주 2 문제씩을 정해서 그 문제를 푸는 연습을 하고 있다.

이번주에는 미리 풀고 싶었던 알고리즘을 정하고 그 알고리즘에 관한 문제를 설정해왔다.

병렬 이분 탐색: Ski Course Rating
내가 어디를 거쳐갔더라?: Block-Cut Tree

두 알고리즘 이름은 들어봤지만 제대로 풀어 본적은 없어서 이번 기회에 그 알고리즘을 공부 하였다.

### Ski Course Rating

문제: 처음 N, M, T값이 주어진다.
N*M 행렬에 높이 값이 주어진다. 
그리고 N*M행렬에 0-1으로 스타트 지점이 주어진다.
이 때 각각의 스타트 지점에서 출발하여서 상하좌우로 움직이면서 적어도 T개의 위치에 갈때 필요한 높이 차의 최솟값의 합을 구하는 문제이다.

모든 정점에 대해서 동시에 이분탐색을 진행하면 된다. 간선 가중치를 다 구하고 그 간선을 다 압축해서 저장합니다. 각 간선들을 이분탐색에 mid값보다 낮은 간선들을 union-find로 머지하는데 이 때 같은 가중치를 가진 간선은 한번에 같이 머지해야합니다. 그리고 쿼리의 mid값을 업데이트하면 됩니다. 

http://boj.kr/a9f46b1356f942bbb84651f52a596747

처음 짜 본 병렬 이분탐색이라 코드가 좀 더럽지만 시간내에 아슬아슬하게 돌아간다.

https://www.acmicpc.net/source/11808572

근데 상위권 사람들의 소스를 보니깐 그냥 union-find를 합치는것만 해도 할 수 있는것으로 보인다. (병렬 이분탐색 과정의 한번의 사이클만으로 답 구하기)

이건 약간의 그리디로 보이는데 크루스칼처럼 간선을 정렬한 후에 차이가 낮은것부터 머지하면서 개수가 T가 넘어가면 정답에 마지막 차이 만큼 더하는것이다. 증명은 하진 않지만 맞는것 같다. 

사실 이풀이도 생각을 했는데 그냥 병렬이분탐색을 안 짜봐서 이걸로 해봤다. 시간복잡도는 log(NM)이 더 붙으니 더 느리지만 시간안에는 돌아간다. 원래 병렬이분탐색이 정해보다는 "뚫는" 경우가 많다 하니 아마 이것도 이런 경우로 생각된다.

### 내가 어디를 거쳐갔더라?

solved.ac 기준으로 다이아몬드 5정도 수준의 문제지만 이 문제가 출제된 UCPC 2015에는 어떤 팀도 못 푼 문제이다(그만큼 PS계의 실력 향상이 급속도로 진행되고 있다.).

문제: 연결 그래프가 주어진다. 쿼리로 두 정점을 주어졌을 때 두 정점을 잇는 경로중에서 두 정점은 한번만 지나면서 지날 수 있는 모든 정점의 개수를 출력하라는 문제

일단 단절점과 관련이 있다. 만약 그 정점이 단절점이라면 그 정점을 기준으로 서로 다른 컴포넌트로 나뉘기 때문이다.

만약의 a-b 쿼리일 때 a b가 둘다 단절점이 아니라면 모든 정점을 갈 수 있다.

단절점이라면 갈 수 없는 정점 개수를 세야하는데 이게 조금 귀찮다. 일단 원래 단절점을 구하는 알고리즘에서 구하는 것처럼 현재 정점에서 갈 수 있는 dfs번호가 가장 작은 값들을 계산하면서 자신의 후손 중에서 자신의 부모로 갈 수 없는 노드의 개수를 세면 된다. 그랬을 때 a와 b가 조상 후손 관계가 아니라면 전체 개수에서 갈 수 없는 개수를 빼면 된다. (N - cnt[a] - cnt[b])

조상-후손 관계인 경우 조금 생각을 해봐야한다. 후손에서 못가는 개수를 빼는건 당연한데 조상에서 못가는 개수를 빼면은 당연히 안된다. 왜냐하면 이 경우에는 조상에서 후손으로 가능 경로에 있는 정점들을 갈 수 있기 때문이다. 조상을 a라고 하면 a의 여러 자식중에서 어떤 자식의 후손이 b일지를 알아내야 한다. 그 a의 자식을 c라 한다면 c의 후손들을 다 갈 수 있다 생각하면서 b에서 못가는 정점은 못가고 거기에 a정점(1)을 더한값이 답이다... (subtree_size[c] - cnt[b] + 1)

그렇다면 이제 문제는 a의 자식중 어떤 자식이 c를 가지고 있는지를 빠르게 계산하는 것이다. 이 때 block-cut tree를 구축해서 (bcc를 하나의 정점으로 봐서 만드는 트리) lca를 구하는 방법으로 조상-후손 관계 파악과, c 파악을 빠르게 할 수 있다. 그러나 이보다 실제 동작 속도가 빠르고 코드도 간편하게 하는 방법이 있다. (처음에는 이렇게 풀었으나 출제자 ainta님의 코드를 보고 알았다.)

ETT를 사용하는 것이다. dfs를 하면서 노드 들어간 번호 나온 번호를 저장해놓는 것이다. 그러면 조상-후손 관계 파악 (st[a] <= st[b] && ed[b] <= ed[a])을 빠르게 할 수 있고 항상 증가하기 때문에 자식의 st, ed값과 b의 st, ed값을 비교하면서 이분탐색으로 c를 알 수 있다. 